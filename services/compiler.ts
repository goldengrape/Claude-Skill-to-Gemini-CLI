
import type { SkillSourceData } from '../types';

// These are loaded from CDNs in index.html
declare var JSZip: any;
declare var saveAs: any;

/**
 * Processes an uploaded .zip file to extract SKILL.MD and referenced files.
 * @param file The .zip file to process.
 * @returns A promise that resolves to the skill source data.
 */
export async function processZipFile(file: File): Promise<SkillSourceData> {
    const zip = await JSZip.loadAsync(file);
    let skillMdFile: any = null;
    let skillMdFilename = '';

    zip.forEach((relativePath: string, zipEntry: any) => {
        if (relativePath.toUpperCase().endsWith('SKILL.MD')) {
            skillMdFile = zipEntry;
            skillMdFilename = relativePath;
        }
    });

    if (!skillMdFile) {
        throw new Error('SKILL.MD not found in the root of the zip file.');
    }

    const skillMdContent = await skillMdFile.async('string');

    // Regex to find local file references like `(./file.js)` or `href="file.html"`
    const fileRefRegex = /(?:\(\s*|\bhref=\s*["'])\.?\/([a-zA-Z0-9_.-]+\.[a-zA-Z0-9]+)/g;
    const referencedFiles: { [filename: string]: string } = {};
    const filePaths = new Set<string>();

    let match;
    while ((match = fileRefRegex.exec(skillMdContent)) !== null) {
        const filePath = match[1];
        if (filePath) {
            filePaths.add(filePath);
        }
    }

    for (const path of Array.from(filePaths)) {
        const fileInZip = zip.file(path);
        if (fileInZip) {
            referencedFiles[path] = await fileInZip.async('string');
        } else {
            console.warn(`Referenced file not found in zip: ${path}`);
        }
    }

    return { skillMdContent, referencedFiles };
}

/**
 * Creates a structured "Context Blob" string from the skill data.
 * @param skillData The extracted skill data.
 * @returns A single string containing all file contents.
 */
export function createContextBlob(skillData: SkillSourceData): string {
    let contextBlob = `--- BEGIN FILE: SKILL.MD ---\n${skillData.skillMdContent}\n--- END FILE: SKILL.MD ---\n\n`;

    for (const [filename, content] of Object.entries(skillData.referencedFiles)) {
        contextBlob += `--- BEGIN FILE: ${filename} ---\n${content}\n--- END FILE: ${filename} ---\n\n`;
    }

    return contextBlob.trim();
}

/**
 * Generates the content for the README.md file.
 * @param commandName The desired Gemini CLI command name (e.g., /art).
 * @param tomlFileName The filename of the generated .toml file.
 * @returns The README content as a string.
 */
function createReadme(commandName: string, tomlFileName: string): string {
    return `
# Gemini CLI Skill: ${commandName}

Thank you for using SkillCompiler!

## 1. Installation

1.  Copy the \`${tomlFileName}\` file from this archive into your Gemini CLI commands directory.
2.  On macOS / Linux, this directory is typically located at: \`~/.gemini/commands/\`
3.  On Windows, this directory is typically located at: \`%APPDATA%\\gemini\\commands\\\`

**macOS / Linux Quick Command:**
(After unzipping, run this command in the same directory)
\`\`\`bash
mkdir -p ~/.gemini/commands/
cp ${tomlFileName} ~/.gemini/commands/
\`\`\`

## 2. Usage

Restart your Gemini CLI if it's running. You can now use the new slash command:

\`\`\`bash
gemini ${commandName} [your arguments...]
\`\`\`
`;
}

/**
 * Generates the final .zip package in memory.
 * @param tomlContent The content of the .toml file generated by Gemini.
 * @param commandName The desired command name.
 * @returns A promise that resolves when the download is initiated.
 */
export async function generateAndDownloadZip(tomlContent: string, commandName: string): Promise<void> {
    const tomlFileName = `${commandName.replace(/^\//, '')}.toml`;
    const readmeContent = createReadme(commandName, tomlFileName);

    const zip = new JSZip();
    zip.file(tomlFileName, tomlContent);
    zip.file('README.md', readmeContent);

    const zipBlob = await zip.generateAsync({ type: 'blob' });
    saveAs(zipBlob, `gemini-skill-${tomlFileName.replace('.toml', '')}.zip`);
}
